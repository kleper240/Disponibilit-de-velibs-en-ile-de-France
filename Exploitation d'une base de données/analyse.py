import matplotlib.pyplot as plt
import mysql.connector


connection = mysql.connector.connect(host="localhost", user="root", password="root", database="velibs")
basedb = connection.cursor()
def cree():
    basedb.execute(""" 
        CREATE VIEW stats_sur_periode_donnée AS
        SELECT s.stationcode, s.name, s.capacity, s.lon, s.lat,
            ss.numdocksavailable, ss.numbikesavailable,
            ss.mechanical, ss.ebike,
            ss.nom_arrondissement_communes, ss.time
        FROM statique ss
        JOIN dynamique s ON ss.stationcode = s.stationcode""")
    # cree()




def capacite(resultat, ville = input("Rentrez une ville : "), typevelo= input("mecanique ou electrique : ")):
    if typevelo == 'mecanique':
        # Données des places libres et vélos mécaniques disponibles
        places_libres = 0
        velos_mecaniques = 0

        for row in resultat:
            if row[6] == ville:
                places_libres += row[2]
                velos_mecaniques += row[2] - row[4]

        # Création du graphique circulaire
        labels = ['Places Libres', 'Vélos Mécaniques']
        sizes = [places_libres, velos_mecaniques]
        colors = ['#00FF00', '#800080']  # Vert et violet
        explode = (0.1, 0)  # Mettre en évidence la première tranche

        plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)
        plt.axis('equal')  # Assurer que le graphique est circulaire

        plt.title('Places Libres et Vélos Mécaniques Disponibles - ' + ville)

        plt.show()
    elif typevelo == 'electrique':
        # Données des places libres et vélos électriques disponibles
        places_libres = 0
        velos_electriques = 0

        for row in resultat:
            if row[6] == ville:
                places_libres += row[2]
                velos_electriques += row[2] - row[5]

        # Création du graphique circulaire
        labels = ['Places Libres', 'Vélos Électriques']
        sizes = [places_libres, velos_electriques]
        colors = ['#00FF00', '#800080']  # Vert et violet
        explode = (0.1, 0)  # Mettre en évidence la première tranche

        plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)
        plt.axis('equal')  # Assurer que le graphique est circulaire

        plt.title('Places Libres et Vélos Électriques Disponibles - ' + ville)

        plt.show()
    else:
        print("Veuillez vérifier l'orthographe du type de vélo.")



def historique(resultat2):
    # Initialisation des compteurs pour chaque heure
    heure_capacite = {}

    # Parcourir les données et compter la capacité pour chaque heure
    for row in resultat2:
        heure = row[7].hour  # Extraire l'heure de la date
        if heure in heure_capacite:
            heure_capacite[heure] += row[9]  # Capacité de la station
        else:
            heure_capacite[heure] = row[9]

    # Trier les heures
    heures = sorted(heure_capacite.keys())

    # Récupérer les capacités correspondantes
    capacites = [heure_capacite[heure] for heure in heures]

    # Création du graphique en barres
    plt.bar(heures, capacites)

    plt.xlabel('Heure')
    plt.ylabel('Capacité')
    plt.title('Capacité des stations par heure')

    plt.show()



def circuler2(resultat, commune_specifique=str(input("rentrez une ville: "))):
    # Extraction des données de commune, mécanique et e-bike
    communes = commune_specifique
    mechanical_counts = [result[4] for result in resultat if result[6] == communes]
    ebike_counts = [result[5] for result in resultat if result[6] == communes]

    # Calcul des pourcentages
    total_mec = sum(int(i) for i in mechanical_counts)
    total_ebi = sum(int(i) for i in ebike_counts)
    total_counts = total_ebi + total_mec

    cal_mec = (total_mec * 100) / total_counts
    cal_elc = (total_ebi * 100) / total_counts

    # Création du diagramme circulaire
    labels = ['Mécanique', 'E-bike']
    sizes = [cal_mec, cal_elc]
    colors = ['#ff9999', '#66b3ff']
    explode = (0.1, 0)  # Sépare le premier segment

    # Personnalisation du graphique
    plt.figure(figsize=(6, 6))  # Définit la taille de la figure
    plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90,
            wedgeprops={'edgecolor': 'white'})  # Ajoute des bordures blanches aux segments
    plt.axis('equal')  # Assure que le diagramme est circulaire
    plt.title("Répartition des vélos à " + commune_specifique, fontweight='bold', fontsize=14)  # Titre en gras et plus grand
    plt.legend(loc='best', fontsize=10)  # Ajoute une légende en bas à droite avec une taille de police plus petite

    # Affichage du diagramme circulaire
    plt.tight_layout()
    plt.show()





# def main():
#     print("1. Capacité des stations par type de vélo et ville.")
#     print("2. Capacité des stations par heure.")
#     print("3. Répartition des vélos mécaniques et électriques par commune.")

#     choix = input("Sélectionnez une option (1/2/3) : ")

#     if choix == "1":
#         ville = input("Rentrez une ville : ")
#         typevelo = input("Mécanique ou électrique : ")
#         capacite(resultat, ville, typevelo)
#     elif choix == "2":
#         historique(resultat2)
#     elif choix == "3":
#         commune_specifique = input("Rentrez une ville : ")
#         circuler2(resultat, commune_specifique)
#     else:
#         print("Option invalide.")

# # Appeler la fonction principale
# main()

# Fermer la connexion à la base de données
connection.commit()
basedb.close()
